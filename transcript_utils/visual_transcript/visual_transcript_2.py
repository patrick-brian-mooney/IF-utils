#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Part of a series of scripts to help process visual screencasts of IF that cannot
produce a regular textual transcript, for whatever reason. (Often, this is
because the IF is quite old, from prior to the expectation that a transcript is
something a player should necessarily be able to create.) THIS script takes the
output files generated by visual_transcript_1.py and eliminates what I think of
as "immediate neighbor duplicates." That is, it goes through all of the folders
in lexicographic order, sequentially checking each file in each folder to see
whether it is an exact (byte-for-byte) duplicate. If it is, the second file
being tested is discarded (i.e., deleted). The intent is to ensure that the
folders containing the output images do not have long stretches of images that
are sequential duplicates. Once it's run, it should probably be followed by
visual_transcript_3.py, which looks for non-sequential near duplicates.

This script gets its operating parameters from visual_transcript_1.py.

This is a pretty quick hack, but works well enough for my purposes.

This program is part of a group of interactive fiction-related utilities by
Patrick Mooney. It is copyright 2018. It is released under the GNU GPL, either
version 3 or (at your option) any later version. See the file LICENSE.md for
details.
"""

import glob, os, time

from visual_transcript_1 import input_files, output_dir

if __name__ == "__main__":
    for which_dir in [os.path.abspath(d) for d in sorted([dir for dir in sorted(glob.glob(output_dir + '/*')) if os.path.isdir(dir)])]:
        try:
            print("\n\nProcessing " + which_dir)
            olddir = os.getcwd()
            os.chdir(which_dir)
            files = sorted(glob.glob("*png"))
            if len(files) > 1:                      # If there aren't at least two files, then there are no duplicates in this folder.
                with open(files[0], 'rb') as the_file:
                    prev_file = the_file.read()
                for i in range(1, len(files)):          # Note that we're starting with index 1, not zero.
                    with open(files[i], 'rb') as the_file:
                        curr_file = the_file.read()
                    if curr_file == prev_file:
                        print('removing ' + files[i])
                        os.unlink(files[i])
                    else:
                        prev_file = curr_file
        except BaseException as err:
            print("ERROR! The system said: %s" % err)
            time.sleep(1.5)
        finally:
           os.chdir(olddir)
